{"mappings":"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","sources":["js/src/fusionCSSTrackElem.js"],"sourcesContent":["/**\n * JavaScript to track elements and optionally stick elements, works with jQuery or fusionLib.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * @package fusionCSS\n * @copyright Copyright (c) 2018 - 2019 fusionCSS. All rights reserved.\n * @link http://fusionCSS.com\n */\n\n(function() {\n\tvar tracked = [],\n\t\tlastScroll = $(window).scrollTop(),\n\t\tstickyList = [];\n\n\t/**\n\t * Test if point reached and trigger handler.\n\t *\n\t * @param int idx The index of the element being updated.\n\t * @param string direction 'up' or 'down' depending on the direction of travel.\n\t */\n\tfunction testTrigger(idx, direction) {\n\t\t// If hit point\n\t\tif(lastScroll >= tracked[idx].top && tracked[idx].before) {\n\t\t\ttracked[idx].before = false;\n\t\t\ttracked[idx].handler.call(tracked[idx].element, direction, tracked[idx]);\n\t\t\ttracked[idx].element.trigger('pointReached', [direction]);\n\t\t}\n\t\telse if(lastScroll < tracked[idx].top && !tracked[idx].before) {\n\t\t\ttracked[idx].before = true;\n\t\t\ttracked[idx].handler.call(tracked[idx].element, direction, tracked[idx]);\n\t\t\ttracked[idx].element.trigger('pointReached', [direction]);\n\t\t}\n\t}\n\n\t$.fn.extend({\n\n\t\t/**\n\t\t * Add tracking to a point.\n\t\t * @param opts { offset, handler }\n\t\t */\n\t\ttrackPoint: function(opts) {\n\t\t\topts = opts ? opts : {};\n\n\t\t\tvar offset = opts.offset ? opts.offset : 0,\n\t\t\t\thandler = opts.handler ? opts.handler : function () {},\n\t\t\t\tonBeforeResize = opts.onBeforeResize ? opts.onBeforeResize : function () {},\n\t\t\t\tonAfterResize = opts.onAfterResize ? opts.onAfterResize : function () {},\n\t\t\t\toffsetType = typeof offset === 'string' && offset.match(/%$/) ? '%' : 'px';\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar el = $(this),\n\t\t\t\t\toffsetPixels = offsetType == '%'\n\t\t\t\t\t\t? ((parseInt(offset) / 100) * $(window).height())\n\t\t\t\t\t\t: parseInt(offset),\n\t\t\t\t\td = {\n\t\t\t\t\t\telement: el,\n\t\t\t\t\t\ttop: el.offset().top - offsetPixels,\n\t\t\t\t\t\tbefore: true,\n\t\t\t\t\t\toffset: offset,\n\t\t\t\t\t\toffsetPixels: offsetPixels,\n\t\t\t\t\t\thandler: handler,\n\t\t\t\t\t\tonBeforeResize: onBeforeResize,\n\t\t\t\t\t\tonAfterResize: onAfterResize\n\t\t\t\t\t};\n\n\t\t\t\t// Remember the element\n\t\t\t\ttracked.push(d);\n\n\t\t\t\t// Wrap the element\n\t\t\t\tel.wrap('<div class=\"trackPointWrapper\"></div>');\n\n\t\t\t\t// If point already reached then flag it\n\t\t\t\tif(lastScroll >= d.top)\n\t\t\t\t\ttestTrigger(tracked.length - 1, 'down');\n\n\t\t\t\t// Sort the tracked list top first\n\t\t\t\ttracked.sort(function(a, b) {\n\t\t\t\t\treturn b.top - a.top;\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Update the offset.\n\t\t *\n\t\t * @param int offset The offset.\n\t\t */\n\t\ttrackPointSetOffset: function(offset) {\n\t\t\tvar offsetType = typeof offset === 'string' && offset.match(/%$/) ? '%' : 'px';\n\n\t\t\treturn this.each(function() {\n\t\t\t\tfor(var i=0;i<tracked.length;i++) {\n\t\t\t\t\tif(this === tracked[i].element[0]) {\n\t\t\t\t\t\tvar oldTop = tracked[i].top,\n\t\t\t\t\t\t\toffsetPixels = offsetType == '%'\n\t\t\t\t\t\t\t\t? ((parseInt(offset) / 100) * $(window).height())\n\t\t\t\t\t\t\t\t: parseInt(offset);\n\n\t\t\t\t\t\ttracked[i].top = tracked[i].element.offset().top - offsetPixels;\n\t\t\t\t\t\ttracked[i].offset = offset;\n\t\t\t\t\t\ttracked[i].offsetPixels = offsetPixels;\n\n\t\t\t\t\t\tif(oldTop != tracked[i].top) {\n\t\t\t\t\t\t\ttestTrigger(i, tracked[i].top > oldTop ? 'up' : 'down');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\t/**\n\t * Tack the scrolling.\n\t */\n\t$(window).on('scroll', function () {\n\t\tvar top = $(window).scrollTop(),\n\t\t\tdirection = top > lastScroll ? 'down' : 'up';\n\n\t\tif(top != lastScroll) {\n\t\t\tlastScroll = top;\n\n\t\t\tfor(var i=0;i<tracked.length;i++) {\n\t\t\t\ttestTrigger(i, direction);\n\t\t\t}\n\t\t}\n\t})\n\n\t/**\n\t * Track resize events.\n\t */\n\t\t.on('resize', function() {\n\t\t\tfor(var i=0;i<tracked.length;i++) {\n\n\t\t\t\t// Call the before resize handler\n\t\t\t\ttracked[i].onBeforeResize.call(tracked[i].element, tracked[i]);\n\n\t\t\t\t// Recalculate the top\n\t\t\t\tvar oldTop = tracked[i].top,\n\t\t\t\t\toffsetType = typeof tracked[i].offset === 'string' && tracked[i].offset.match(/%$/) ? '%' : 'px',\n\t\t\t\t\toffsetPixels = offsetType == '%'\n\t\t\t\t\t\t? ((parseInt(tracked[i].offset) / 100) * $(window).height())\n\t\t\t\t\t\t: parseInt(tracked[i].offset);\n\n\t\t\t\ttracked[i].top = tracked[i].element.offset().top - offsetPixels;\n\t\t\t\ttracked[i].offsetPixels = offsetPixels;\n\n\t\t\t\tif(oldTop != tracked[i].top) {\n\t\t\t\t\ttestTrigger(i, tracked[i].top > oldTop ? 'up' : 'down');\n\t\t\t\t}\n\n\t\t\t\t// Call the after resize handler\n\t\t\t\ttracked[i].onAfterResize.call(tracked[i].element, tracked[i]);\n\t\t\t}\n\t\t});\n\n\t/**\n\t * Calculate the offsets for each element.\n\t *\n\t * @param opts\n\t * @return {*}\n\t * @private\n\t */\n\tfunction _calcOffset(opts) {\n\t\tvar offset = opts.offset;\n\t\tif(opts.stoppedBy) {\n\n\t\t\t// Work up tree to see if parents have an offset\n\t\t\tvar el = opts.stoppedBy;\n\t\t\tdo {\n\t\t\t\toffset += el.outerHeight(true);\n\t\t\t\tel = el[0]._stickyOpts ? el[0]._stickyOpts.stoppedBy : null;\n\t\t\t} while(el);\n\t\t}\n\n\t\treturn offset;\n\t}\n\n\t/**\n\t * Implement sticky elements\n\t */\n\t$.fn.extend({\n\n\t\t/**\n\t\t * Configure element to stick on scroll.\n\t\t *\n\t\t * @param map opts configuration options.\n\t\t */\n\t\tstickyOnScroll: function(opts) {\n\t\t\topts = opts ? opts : {};\n\n\t\t\topts.stuckClass = opts.stuckClass ? opts.stuckClass : 'stuck';\n\t\t\topts.handler = opts.handler ? opts.handler : function() {};\n\t\t\topts.offset = opts.offset ? opts.offset : 0;\n\t\t\topts.stuck = false;\n\t\t\topts.stoppedBy = opts.stoppedBy ? opts.stoppedBy : null;\n\t\t\topts.releasedBy = opts.releasedBy ? opts.releasedBy : null;\n\t\t\topts.releasedByEdge = opts.releasedByEdge ? opts.releasedByEdge : 'bottom';\n\t\t\topts.released = false;\n\t\t\topts.setTop = typeof opts.setTop !== 'undefined' ? opts.setTop : true;\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar el = $(this);\n\t\t\t\tel[0]._stickyOpts = opts;\n\n\t\t\t\t// Add handler to the element\n\t\t\t\tel.trackPoint({\n\t\t\t\t\t// Handle the tracked point crossing the boundry\n\t\t\t\t\thandler: function(direction, trackData) {\n\t\t\t\t\t\tvar opts = this[0]._stickyOpts;\n\n\t\t\t\t\t\tif(direction == 'down') {\n\n\t\t\t\t\t\t\t// Stick the element\n\t\t\t\t\t\t\topts.stuck = true;\n\t\t\t\t\t\t\tthis.parent().height(this.outerHeight(true));\n\t\t\t\t\t\t\tthis.addClass(opts.stuckClass);\n\t\t\t\t\t\t\tif(opts.setTop)\n\t\t\t\t\t\t\t\tthis.css('top', trackData.offsetPixels + 'px');\n\t\t\t\t\t\t\topts.handler.call(this, 'stuck');\n\t\t\t\t\t\t\tthis.trigger('stuck');\n\n\t\t\t\t\t\t\t// If have a release element recalculate the offsets\n\t\t\t\t\t\t\tif(opts.releasedBy) {\n\t\t\t\t\t\t\t\topts.releasedBy.trackPointSetOffset(\n\t\t\t\t\t\t\t\t\t-(opts.releasedByEdge === 'top' ? 0 : opts.releasedBy.outerHeight(false)) + (this.position().top + this.outerHeight(false))\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(direction == 'up') {\n\n\t\t\t\t\t\t\t// Unstick element\n\t\t\t\t\t\t\topts.stuck = false;\n\t\t\t\t\t\t\tthis.parent().height('');\n\t\t\t\t\t\t\tthis.removeClass(opts.stuckClass);\n\t\t\t\t\t\t\topts.handler.call(this, 'unstuck');\n\t\t\t\t\t\t\tthis.trigger('unstuck');\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// Handle window resize events for stuck elements\n\t\t\t\t\tonBeforeResize: function() {\n\n\t\t\t\t\t\t// If the element is stuck then update the size of the spacer\n\t\t\t\t\t\tif(this[0]._stickyOpts.stuck) {\n\t\t\t\t\t\t\tthis.parent().height('');\n\t\t\t\t\t\t\tthis.removeClass(opts.stuckClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.trackPointSetOffset(_calcOffset(this[0]._stickyOpts));\n\t\t\t\t\t},\n\t\t\t\t\tonAfterResize: function(trackData) {\n\t\t\t\t\t\t// If the element is stuck then update the size of the spacer\n\t\t\t\t\t\tif(this[0]._stickyOpts.stuck) {\n\t\t\t\t\t\t\tthis.parent().height(this.outerHeight(true));\n\t\t\t\t\t\t\tthis.addClass(opts.stuckClass).css('top', trackData.offsetPixels + 'px');\n\n\t\t\t\t\t\t\t// If have a release element recalculate the offsets\n\t\t\t\t\t\t\tif(opts.releasedBy) {\n\t\t\t\t\t\t\t\topts.releasedBy.trackPointSetOffset(\n\t\t\t\t\t\t\t\t\t-(opts.releasedByEdge === 'top' ? 0 : opts.releasedBy.outerHeight(false)) + (this.position().top + this.outerHeight(false))\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\toffset: _calcOffset(opts) //opts.offset\n\t\t\t\t});\n\n\t\t\t\t// If a lower element can bump the element to unstick then track\n\t\t\t\tif(opts.releasedBy) {\n\t\t\t\t\topts.releasedBy.trackPoint({\n\t\t\t\t\t\thandler: function(direction, trackData) {\n\t\t\t\t\t\t\tvar opts = el[0]._stickyOpts;\n\t\t\t\t\t\t\tif(opts.stuck) {\n\t\t\t\t\t\t\t\tif (direction == 'up') {\n\t\t\t\t\t\t\t\t\tel.addClass(opts.stuckClass);\n\t\t\t\t\t\t\t\t\topts.released = false;\n\t\t\t\t\t\t\t\t} else if (direction == 'down') {\n\t\t\t\t\t\t\t\t\tel.removeClass(opts.stuckClass);\n\t\t\t\t\t\t\t\t\topts.released = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonBeforeResize: function() {\n\t\t\t\t\t\t\tif(el[0]._stickyOpts.released && el[0]._stickyOpts.stuck)\n\t\t\t\t\t\t\t\tel.add(opts.stuckClass);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonAfterResize: function(trackData) {\n\t\t\t\t\t\t\tif(el[0]._stickyOpts.released && el[0]._stickyOpts.stuck)\n\t\t\t\t\t\t\t\tel.removeClass(opts.stuckClass);\n\t\t\t\t\t\t},\n\t\t\t\t\t\toffset: -(opts.releasedByEdge === 'top' ? 0 : opts.releasedBy.outerHeight(false)) + (el.position().top + el.outerHeight(false))\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Mark the wrapper class\n\t\t\t\tel.parent().addClass('stickyWrapper');\n\n\t\t\t\t// Remember the element\n\t\t\t\tstickyList.push(el);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Set the offset for sticky.\n\t\t *\n\t\t * @param offset The offset.\n\t\t */\n\t\tstickyOnScrollOffset: function(offset) {\n\t\t\treturn this.each(function() {\n\t\t\t\tthis._stickyOpts.offset = offset;\n\t\t\t\t$(this).trackPointSetOffset(_calcOffset(this._stickyOpts));\n\t\t\t});\n\t\t}\n\t});\n\n})();\n"],"names":["tracked","lastScroll","$","window","scrollTop","stickyList","testTrigger","idx","direction","top","before","handler","call","element","trigger","_calcOffset","opts","offset","stoppedBy","el","outerHeight","_stickyOpts","fn","extend","trackPoint","onBeforeResize","onAfterResize","offsetType","match","this","each","offsetPixels","parseInt","height","d","push","wrap","length","sort","a","b","trackPointSetOffset","i","oldTop","on","stickyOnScroll","stuckClass","stuck","releasedBy","releasedByEdge","released","setTop","trackData","parent","addClass","css","position","removeClass","add","stickyOnScrollOffset"],"version":3,"file":"fusionCSSTrackElem.js.map"}